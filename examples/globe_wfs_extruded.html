<html>
    <head>
        <title>Itowns - Globe + WFS</title>
        <link rel="stylesheet" type="text/css" href="globe_wfs_extruded.css">
        <meta charset="UTF-8">

        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <script src="GUI/dat.gui/dat.gui.min.js"></script>
    </head>
    <body>
        <div id="viewerDiv"></div>
        <div id="batchInformationDiv">
            <p><b>Information Batiment</b></p>
            <ul id="info">
            </ul>
        </div>

        <script src="GUI/GuiTools.js"></script>
        <script src="../dist/itowns.js"></script>
        <script src="../dist/debug.js"></script>
        <script type="text/javascript">
            var renderer;
            var exports = {};
        </script>
        <script src="globe_wfs_extruded.js">
            console.log('label');
        </script>
        <script type="text/javascript">

            // Global variable that contains for each building (key) a list of iportant buildings (value)
            var elementsLinked = {
                "bati_indifferencie.17807922" :["bati_indifferencie.3616112"],
                "bati_indifferencie.17807920" :["bati_indifferencie.3616112"],
                "bati_industriel.2339424" :["bati_indifferencie.3616112"],
                "bati_indifferencie.28964625" :["bati_indifferencie.3616112"],
                "bati_indifferencie.3672662" :["bati_indifferencie.3616112"],
                "bati_indifferencie.3672661" :["bati_indifferencie.3616112"],
                "bati_industriel.284404" :["bati_indifferencie.3616112"],
                "bati_industriel.284403" :["bati_indifferencie.3616112"],
                "bati_indifferencie.4127882" :["bati_indifferencie.3616112"]
            };

            //var linkedElements = reverseJson(elementsLinked)// batiment parent = principale, batiments enfants
            
            // Global variable that contains the current selected buildings
    	    var selectedBuild=[];

            /* global itowns, document, GuiTools, globeView, promises */
            var globeMenu = new GuiTools('menuDiv');
            globeMenu.view = globeView;

            //Listen for globe full initialisation event
            globeView.addEventListener(itowns.GLOBE_VIEW_EVENTS.GLOBE_INITIALIZED, function () {
                // eslint-disable-next-line no-console
                console.info('Globe initialized');
                Promise.all(promises).then(function () {
                    //globeMenu.addImageryLayersGUI(globeView.getLayers(function (l) { return l.type === 'color'; }));
                    //globeMenu.addElevationLayersGUI(globeView.getLayers(function (l) { return l.type === 'elevation'; }));
                    addMeshToScene();
                    globeMenu.gui.add({ WatherLevel: 0.0}, 'WatherLevel').min(-10.0).max(50.0).onChange((
                        function updateWatherLevel(value) {
                            adjustAltitude(value);
                            checkWaterHeightForBuildings(168 + value);
                            globeView.notifyChange(true);
                        }));
                    globeView.controls.setTilt(45, true);
                    checkWaterHeightForBuildings(168);
                    //var coordsElementsLinked = extract_coords(); //id_BDTopo élément, coordonnées : [long, lat, alti]
                });
            });
            //var d = new debug.Debug(globeView, globeMenu.gui);
            //debug.createTileDebugUI(globeMenu.gui, globeView, globeView.wgs84TileLayer, d);

            for (const layer of globeView.getLayers()) {
                if (layer.id === 'WFS Bus lines') {
                    layer.whenReady.then( function _(layer) {
                        var gui = debug.GeometryDebug.createGeometryDebugUI(globeMenu.gui, globeView, layer);
                        debug.GeometryDebug.addMaterialLineWidth(gui, globeView, layer, 1, 10);
                    });
                }
                if (layer.id === 'WFS Buildings') {
                     layer.whenReady.then( function _(layer) {
                //         var gui = debug.GeometryDebug.createGeometryDebugUI(globeMenu.gui, globeView, layer);
                //         debug.GeometryDebug.addWireFrameCheckbox(gui, globeView, layer);
                         window.addEventListener('mousemove', picking, false);
                         window.addEventListener('click', picking2, false);
                     });
                }
                if (layer.id === 'WFS Route points') {
                    layer.whenReady.then( function _(layer) {
                        var gui = debug.GeometryDebug.createGeometryDebugUI(globeMenu.gui, globeView, layer);
                        debug.GeometryDebug.addMaterialSize(gui, globeView, layer, 1, 50);
                    });
                }
            }

            /////////////////////////////////////////// Function and methods part ///////////////////////////////////////////

            function picking(event) {
                // Pick an object with batch id
                var mouse = globeView.eventToNormalizedCoords(event);
                var raycaster = new itowns.THREE.Raycaster();
                var htmlInfo = document.getElementById('info');
                htmlInfo.innerHTML = ' ';
		
		        var a = globeView.scene.getObjectByName("test");
		        if (a) globeView.scene.remove(a);

                raycaster.setFromCamera(mouse, globeView.camera.camera3D);
                // calculate objects intersecting the picking ray
                for (let i =0; i< selectedBuild.length; i++){
                    let tmpColl = colorAllObjectWithId(selectedBuild[i][0], selectedBuild[i][1], selectedBuild[i][2]);
                }
                selectedBuild=[];
                var intersects = raycaster.intersectObjects(globeView.wgs84TileLayer.level0Nodes, true);
                for (let i = 0; i < intersects.length; i++) {
                    var interAttributes = intersects[i].object.geometry.attributes;
                    if (interAttributes && intersects[i].object instanceof itowns.THREE.Mesh) {
                        if (interAttributes.id && intersects[i]) {
                            //console.log(intersects[i]);
                            var face = intersects[i].face.a;
                            var id = interAttributes.id.array[face];
                            var batchTable = intersects[i].object.parent.features[id].properties;
                            // console.log(intersects[i], batchTable,batchTable.z_min);
                            selectedBuild.push([intersects[i], id, []]);
                            let tmpColl = colorAllObjectWithId(intersects[i], id, [0, 0, 0]);
                            let averageCoordinates = coordsAvgAllObjectWithId(intersects[i].object, id);
                            selectedBuild[selectedBuild.length-1][2]=tmpColl;
                            Object.keys(batchTable).map(function(objectKey) {
                                var value = batchTable[objectKey];
                                // if the value is a integer or not
                                var info = value.toString();
                                htmlInfo.innerHTML +='<li><b>' + objectKey.toString() + ': </b>'+ info +'</li>';
                                return true;
                            });
                            htmlInfo.innerHTML +='<li><b>position moy : </b> ['+ averageCoordinates[0] +', '+ averageCoordinates[1] + ', '+ (batchTable.hauteur/2+ batchTable.z_min) +']</li>';
                            averageCoordinates[2]*=batchTable.hauteur+ batchTable.z_max + 15 ;
                            //averageCoordinates=[intersects[i].point.x, intersects[i].point.y, intersects[i].point.z];
                            addMarker(averageCoordinates, 0xff0000, "test");
                            return;
                        }
                    }
                }    
            }

            function picking2(event) {
                // Pick an object with batch id
                var mouse = globeView.eventToNormalizedCoords(event);
                var raycaster = new itowns.THREE.Raycaster();
                var htmlInfo = document.getElementById('info');
                htmlInfo.innerHTML = ' ';
		
		        var a = globeView.scene.getObjectByName("test");
		        if (a) globeView.scene.remove(a);

                raycaster.setFromCamera(mouse, globeView.camera.camera3D);
                // calculate objects intersecting the picking ray
                for (let i =0; i< selectedBuild.length; i++){
                    let tmpColl = colorAllObjectWithId(selectedBuild[i][0], selectedBuild[i][1], selectedBuild[i][2]);
                }
                selectedBuild=[];
                var intersects = raycaster.intersectObjects(globeView.wgs84TileLayer.level0Nodes, true);
                for (let i = 0; i < intersects.length; i++) {
                    var interAttributes = intersects[i].object.geometry.attributes;
                    if (interAttributes && intersects[i].object instanceof itowns.THREE.Mesh) {
                        if (interAttributes.id) {
                            //console.log(intersects[i]);
                            var face = intersects[i].face.a;
                            var id = interAttributes.id.array[face];
                            var batchTable = intersects[i].object.parent.features[id].properties;
                            console.log(batchTable.id);
                            /*// console.log(intersects[i], batchTable,batchTable.z_min);
                            selectedBuild.push([intersects[i], id, []])
                            let tmpColl = colorAllObjectWithId(intersects[i], id, [0, 0, 0]);
                            let averageCoordinates = coordsAvgAllObjectWithId(intersects[i].object, id);
                            selectedBuild[selectedBuild.length-1][2]=tmpColl;
                            Object.keys(batchTable).map(function(objectKey) {
                                var value = batchTable[objectKey];
                                // if the value is a integer or not
                                var info = value.toString();
                                htmlInfo.innerHTML +='<li><b>' + objectKey.toString() + ': </b>'+ info +'</li>';
                                return true;
                            });
                            htmlInfo.innerHTML +='<li><b>position moy : </b> ['+ averageCoordinates[0] +', '+ averageCoordinates[1] + ', '+ (batchTable.hauteur/2+ batchTable.z_min) +']</li>';
                            averageCoordinates[2]*=batchTable.hauteur+ batchTable.z_max + 15 ;
                            //averageCoordinates=[intersects[i].point.x, intersects[i].point.y, intersects[i].point.z];
                            addMarker(averageCoordinates, 0xff0000, "test");*/
                            return;
                        }
                    }
                }   
            }

            //
            function colorAllObjectWithId(mesh, id, color){
		        var tmpColl = []
                for(let i=0; i< mesh.object.geometry.attributes.id.array.length; ++i){      
                    if (mesh.object.geometry.attributes.id.array[i] == id){
                        tmpColl.push(mesh.object.geometry.attributes.color.array[i*3])
                        tmpColl.push(mesh.object.geometry.attributes.color.array[i*3+1])
                        tmpColl.push(mesh.object.geometry.attributes.color.array[i*3+2])

                        mesh.object.geometry.attributes.color.array[i*3] = color[0];
                        mesh.object.geometry.attributes.color.array[i*3+1] = color[1];
                        mesh.object.geometry.attributes.color.array[i*3+2] = color[2];
                    }
                }
                mesh.object.geometry.attributes.color.needsUpdate = true; 
                globeView.notifyChange(true);
		        return tmpColl;
            }

            // Function that calculates the center coordinates of a mesh.
            function coordsAvgAllObjectWithId(mesh, id){
                var tmpCoord = [0, 0, 0];
                var maxZ = 0;
                var count = 0;
                for(let i=0; i< mesh.geometry.attributes.id.array.length; ++i){      
                    if (mesh.geometry.attributes.id.array[i] == id){
                        //console.log(mesh.pos[i]);
                        const coordinates = mesh.pos[i].as('EPSG:4326');  // Geographic system
                        tmpCoord[0] += coordinates.latitude();
                        tmpCoord[1] += coordinates.longitude();
                        tmpCoord[2] += coordinates.altitude();
                        count++;
                    }
                }
                tmpCoord[0] /=count;
                tmpCoord[1] /=count;
                tmpCoord[2] /=count;
		        return tmpCoord;
            }

            // Dumb function as an example to color buildings under water
            // Should obviously be done in shaders but it shows how to access building meshes attribute
            function checkWaterHeightForBuildings(value) {
                console.log("e");
                // For all globe tile meshes we look for tile at level 14 on which building meshes are attached.
                for (let i = 0; i < globeView.wgs84TileLayer.level0Nodes.length; ++i) {
                    globeView.wgs84TileLayer.level0Nodes[i].traverse(function (element) {
                        //  console.log("ELEMENT: ", element);
                        if (element.level != undefined && element.level == 14 && element.visible) {
                            //console.log(element);
                            for (let c = 0; c < element.children.length; ++c) {

                                if (element.children[c].type == "Group") {
                                    var parent = element.children[c];
                                    var mesh = element.children[c].children[0];
                                    for (let j = 0; j < mesh.geometry.attributes.zmin.count; ++j) {
                                        let id = mesh.geometry.attributes.id.array[j];
                                        if (parent.features[id].properties.id == "bati_indifferencie.3616112"){
                                            //console.log(id);
                                            //console.log(parent.features[id].properties);
                                            mesh.geometry.attributes.color.array[j * 3] = 255;
                                            mesh.geometry.attributes.color.array[j * 3 + 1] = 0;
                                            mesh.geometry.attributes.color.array[j * 3 + 2] = 0;
                                            mesh.geometry.attributes.color.needsUpdate = true;
                                            var h = mesh.geometry.attributes.zmin.array[j]; 
                                            if (h > 0 && h < value) {
                                                var coord = coordsAvgAllObjectWithId(mesh, id);
                                                coord[2]*=parent.features[id].properties.hauteur+ parent.features[id].properties.z_max + 15 ;
                                                var a = globeView.scene.getObjectByName("test2");
	                                            if (!a) addMarker(coord, 0xffff00, "test2");
                                            } else {
                                                var a = globeView.scene.getObjectByName("test2");
	                                            if (a) globeView.scene.remove(a);
                                            }
                                        } else if (elementsLinked[parent.features[id].properties.id] && isLinked(parent.features[id].properties.id, "bati_indifferencie.3616112")){
                                            var b = globeView.scene.getObjectByName("test2"); 
                                            if (b) {
                                                mesh.geometry.attributes.color.array[j * 3] = 0;
                                                mesh.geometry.attributes.color.array[j * 3 + 1] = 255;
                                                mesh.geometry.attributes.color.array[j * 3 + 2] = 255;
                                                mesh.geometry.attributes.color.needsUpdate = true;
                                            }else{
                                                mesh.geometry.attributes.color.array[j * 3] = 0;
                                                mesh.geometry.attributes.color.array[j * 3 + 1] = 255;
                                                mesh.geometry.attributes.color.array[j * 3 + 2] = 0;
                                                mesh.geometry.attributes.color.needsUpdate = true;
                                            }
                                        }
                                        else{
                                            var h = mesh.geometry.attributes.zmin.array[j]; 
                                            if (h > 0 && h < value) {
                                                mesh.geometry.attributes.color.array[j * 3] = 5 * (value - h);
                                                mesh.geometry.attributes.color.array[j * 3 + 1] = 0;
                                                mesh.geometry.attributes.color.array[j * 3 + 2] = 255;
                                                mesh.geometry.attributes.color.needsUpdate = true;
                                            }else{
                                                mesh.geometry.attributes.color.array[j * 3] = 255;
                                                mesh.geometry.attributes.color.array[j * 3 + 1] = 255;
                                                mesh.geometry.attributes.color.array[j * 3 + 2] = 255;
                                                mesh.geometry.attributes.color.needsUpdate = true;
                                            }
                                        }
                                        
                                    }
                                }
                            }

                        }

                    })

                    globeView.notifyChange(true);
                }
            }

            // add  marker at the position describe by coords
            function addMarker(coords, color, name) {
                // creation of the new mesh (a cylinder)
                //console.log("e");
                var THREE = itowns.THREE;
                var geometry = new THREE.CylinderGeometry(20, 20, 3, 8);
                var material = new THREE.MeshBasicMaterial({ color: color });
                var mesh = new THREE.Mesh(geometry, material);

                // get the position on the globe, from the camera
                
                // position of the mesh
                //var meshCoord = new THREE.Vector3(coords[0], coords[1], coords[2]);
                var meshCoord = new itowns.Coordinates('EPSG:4326', coords[1], coords[0], coords[2]);
                //console.log(meshCoord.as(globeView.referenceCrs));
                // position and orientation of the mesh
                mesh.name=name;
                mesh.position.copy(meshCoord.as(globeView.referenceCrs).xyz());
                mesh.lookAt(new THREE.Vector3(0, 0, 0));
                //mesh.rotateX(Math.PI / 2);

                // update coordinate of the mesh
                mesh.updateMatrixWorld();
                //console.log(mesh);
                // add the mesh to the scene
                globeView.scene.add(mesh);
            }

            function isLinked(key, value){
                for (let t = 0; t<elementsLinked[key].length; t++){
                    if(elementsLinked[key][t]==value){
                        return true;
                    }
                }
                return false;
            }

            function createLine(parent){
                if(!coordsElementsLinked){
                    var coordsElementsLinked = extract_coords();//id_BDTopo élément, coordonnées : [long, lat, alti]
                }
                for (let i =0; i<linkedElements[parent].length; i++){
                    coords1=coordsElementsLinked[parent];
                    coords2=coordsElementsLinked[linkedElements[parent][i]];
                    var material = new THREE.LineBasicMaterial({
                        color: 0x0000ff
                    });
                    var meshcoord1 = new itowns.Coordinates('EPSG:4326', coords1[1], coords1[0], coords1[2]).as(globeView.referenceCrs);
                    var meshCoord2 = new itowns.Coordinates('EPSG:4326', coords2[1], coords2[0], coords2[2]).as(globeView.referenceCrs);
                    var geometry = new THREE.Geometry();
                    geometry.vertices.push(
                        new THREE.Vector3( meshcoord1.x(), meshcoord1.y(), meshcoord1.z()),
                        new THREE.Vector3( meshCoord2.x(), meshCoord2.y(), meshCoord2.z())
                    );

                    var line = new THREE.Line( geometry, material );
                    globeView.scene.add( line );
                }                
            }

            function reverseJson(json){
                var tmp ={};
                Object.keys(json).map(function(objectKey) {
                    var value = json[objectKey];
                    if (tmp[value]){
                        tmp[value]=[];
                    }
                    tmp[value].push(objectKey);
                });
                return tmp;
            }

        </script>
    </body>
</html>
