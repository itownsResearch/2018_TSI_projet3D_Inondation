<html>
    <head>
        <title>Itowns - Globe + WFS</title>
        <link rel="stylesheet" type="text/css" href="globe_wfs_extruded.css">
        <meta charset="UTF-8">

        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <script src="GUI/dat.gui/dat.gui.min.js"></script>
    </head>
    <body>
        <div id="viewerDiv"></div>
        <div id="batchInformationDiv">
            <p><b>Information Batiment</b></p>
            <ul id="info">
            </ul>
        </div>

        <script src="GUI/GuiTools.js"></script>
        <script src="../dist/itowns.js"></script>
        <script src="../dist/debug.js"></script>
        <script type="text/javascript">
            var renderer;
            var exports = {};
        </script>
        <script src="globe_wfs_extruded.js">
            console.log('label');
        </script>
        <script type="text/javascript">

            // Global variable that contains for each building (key) a list of important buildings (value)
            var elementsLinked = {
                "bati_indifferencie.17807922" :["bati_indifferencie.3616112","bati_indifferencie.4127882"],
                "bati_indifferencie.17807920" :["bati_indifferencie.3616112","bati_indifferencie.4127882"],
                "bati_industriel.2339424" :["bati_indifferencie.3616112","bati_indifferencie.4127882"],
                "bati_indifferencie.28964625" :["bati_indifferencie.3616112"],
                "bati_indifferencie.3672662" :["bati_indifferencie.3616112"],
                "bati_indifferencie.3672661" :["bati_indifferencie.3616112"],
                "bati_industriel.284404" :["bati_indifferencie.4127882"],
                "bati_industriel.284403" :["bati_indifferencie.4127882"]
            };

            // Global variable that contains for each important building (key) a list buildings (value)
            var linkedElements = reverseJson(elementsLinked);

            // Global variable that contains for each important building (key) the list of its attributes (value)
            var importantBuildings = {
                "bati_indifferencie.3616112":["electric","water"],
                "bati_indifferencie.4127882":["hospital"]
            };

            // Global variable that contains for each important building attributes (key) the list of important buildings (value)
            var attributeBuildings = reverseJson(importantBuildings);

            var coordinatesImportantBuildings={};
            

            // Global variable that contains the current selected buildings
    	    var selectedBuild=[];

            /* global itowns, document, GuiTools, globeView, promises */
            var globeMenu = new GuiTools('menuDiv');
            globeMenu.view = globeView;

            //Listener for globe full initialisation event
            globeView.addEventListener(itowns.GLOBE_VIEW_EVENTS.GLOBE_INITIALIZED, function () {

                //////// eslint-disable-next-line no-console

                console.info('Globe initialized');

                Promise.all(promises).then(function () {

                    ////////globeMenu.addImageryLayersGUI(globeView.getLayers(function (l) { return l.type === 'color'; }));
                    ////////globeMenu.addElevationLayersGUI(globeView.getLayers(function (l) { return l.type === 'elevation'; }));

                    addMeshToScene();

                    // here the gui tools that permits to set the water level and to update the scene along that
                    globeMenu.gui.add({ WatherLevel: 0.0}, 'WatherLevel').min(-10.0).max(50.0).onChange((
                        function updateWatherLevel(value) {

                            adjustAltitude(value); // WHAT DOES IT DO ???

                            removeOldInteractions();

                            displayAllInteractionsForFloodedImportantBuildings(168 + value); // WHY +168 ?


                            //here add other methods


                            globeView.notifyChange(true);
                        }
                    ));


                    //here add other GUI tools


                    globeView.controls.setTilt(45, true);

                    // initialisation of the checkWaterHeightForBuildings
                    displayAllInteractionsForFloodedImportantBuildings(168);

                    ////////var coordsElementsLinked = extract_coords(); //id_BDTopo élément, coordonnées : [long, lat, alti]

                });
            });

            ////////var d = new debug.Debug(globeView, globeMenu.gui);
            ////////debug.createTileDebugUI(globeMenu.gui, globeView, globeView.wgs84TileLayer, d);

            // WHAT DOES IT DO UNDER ???
            for (const layer of globeView.getLayers()) {
                if (layer.id === 'WFS Bus lines') {
                    layer.whenReady.then( function _(layer) {
                        var gui = debug.GeometryDebug.createGeometryDebugUI(globeMenu.gui, globeView, layer);
                        debug.GeometryDebug.addMaterialLineWidth(gui, globeView, layer, 1, 10);
                    });
                }
                if (layer.id === 'WFS Buildings') {
                     layer.whenReady.then( function _(layer) {

                        ////////var gui = debug.GeometryDebug.createGeometryDebugUI(globeMenu.gui, globeView, layer);
                        ////////debug.GeometryDebug.addWireFrameCheckbox(gui, globeView, layer);

                         window.addEventListener('mousemove', normalMouseMouse, false);
                         window.addEventListener('click', normalMouseClick, false);
                     });
                }
                if (layer.id === 'WFS Route points') {
                    layer.whenReady.then( function _(layer) {
                        var gui = debug.GeometryDebug.createGeometryDebugUI(globeMenu.gui, globeView, layer);
                        debug.GeometryDebug.addMaterialSize(gui, globeView, layer, 1, 50);
                    });
                }
            }

            /////////////////////////////////////////// Functions and methods part ///////////////////////////////////////////

            function normalMouseMouse(event) {
                // Pick an object with batch id
                var mouse = globeView.eventToNormalizedCoords(event);
                var raycaster = new itowns.THREE.Raycaster();
                var htmlInfo = document.getElementById('info');
                htmlInfo.innerHTML = ' ';
		
		        var a = globeView.scene.getObjectByName("test");
		        if (a) globeView.scene.remove(a);

                raycaster.setFromCamera(mouse, globeView.camera.camera3D);
                // calculate objects intersecting the picking ray
                for (let i =0; i< selectedBuild.length; i++){
                    let tmpColl = colorAllObjectWithId(selectedBuild[i][0], selectedBuild[i][1], selectedBuild[i][2]);
                }
                selectedBuild=[];
                var intersects = raycaster.intersectObjects(globeView.wgs84TileLayer.level0Nodes, true);
                for (let i = 0; i < intersects.length; i++) {
                    var interAttributes = intersects[i].object.geometry.attributes;
                    if (interAttributes && intersects[i].object instanceof itowns.THREE.Mesh) {
                        if (interAttributes.id && intersects[i]) {
                            //console.log(intersects[i]);
                            var face = intersects[i].face.a;
                            var id = interAttributes.id.array[face];
                            var batchTable = intersects[i].object.parent.features[id].properties;
                            // console.log(intersects[i], batchTable,batchTable.z_min);
                            selectedBuild.push([intersects[i], id, []]);
                            let tmpColl = colorAllObjectWithId(intersects[i], id, [0, 0, 0]);
                            let averageCoordinates = coordsAvgAllObjectWithId(intersects[i].object, id);
                            selectedBuild[selectedBuild.length-1][2]=tmpColl;
                            Object.keys(batchTable).map(function(objectKey) {
                                var value = batchTable[objectKey];
                                // if the value is a integer or not
                                var info = value.toString();
                                htmlInfo.innerHTML +='<li><b>' + objectKey.toString() + ': </b>'+ info +'</li>';
                                return true;
                            });
                            htmlInfo.innerHTML +='<li><b>position moy : </b> ['+ averageCoordinates[0] +', '+ averageCoordinates[1] + ', '+ (batchTable.hauteur/2+ batchTable.z_min) +']</li>';
                            averageCoordinates[2]*=batchTable.hauteur+ batchTable.z_max + 15 ;
                            //averageCoordinates=[intersects[i].point.x, intersects[i].point.y, intersects[i].point.z];
                            addMarker(averageCoordinates, 0xff0000, "test");
                            return;
                        }
                    }
                }    
            }

            function normalMouseClick(event) {
                // Pick an object with batch id
                var mouse = globeView.eventToNormalizedCoords(event);
                var raycaster = new itowns.THREE.Raycaster();
                var htmlInfo = document.getElementById('info');
                htmlInfo.innerHTML = ' ';
		
		        var a = globeView.scene.getObjectByName("test");
		        if (a) globeView.scene.remove(a);

                raycaster.setFromCamera(mouse, globeView.camera.camera3D);
                // calculate objects intersecting the picking ray
                for (let i =0; i< selectedBuild.length; i++){
                    let tmpColl = colorAllObjectWithId(selectedBuild[i][0], selectedBuild[i][1], selectedBuild[i][2]);
                }
                selectedBuild=[];
                var intersects = raycaster.intersectObjects(globeView.wgs84TileLayer.level0Nodes, true);
                for (let i = 0; i < intersects.length; i++) {
                    var interAttributes = intersects[i].object.geometry.attributes;
                    if (interAttributes && intersects[i].object instanceof itowns.THREE.Mesh) {
                        if (interAttributes.id) {
                            //console.log(intersects[i]);
                            var face = intersects[i].face.a;
                            var id = interAttributes.id.array[face];
                            var batchTable = intersects[i].object.parent.features[id].properties;
                            console.log(batchTable.id);

                            /*// console.log(intersects[i], batchTable,batchTable.z_min);
                            selectedBuild.push([intersects[i], id, []])
                            let tmpColl = colorAllObjectWithId(intersects[i], id, [0, 0, 0]);
                            let averageCoordinates = coordsAvgAllObjectWithId(intersects[i].object, id);
                            selectedBuild[selectedBuild.length-1][2]=tmpColl;
                            Object.keys(batchTable).map(function(objectKey) {
                                var value = batchTable[objectKey];
                                // if the value is a integer or not
                                var info = value.toString();
                                htmlInfo.innerHTML +='<li><b>' + objectKey.toString() + ': </b>'+ info +'</li>';
                                return true;
                            });
                            htmlInfo.innerHTML +='<li><b>position moy : </b> ['+ averageCoordinates[0] +', '+ averageCoordinates[1] + ', '+ (batchTable.hauteur/2+ batchTable.z_min) +']</li>';
                            averageCoordinates[2]*=batchTable.hauteur+ batchTable.z_max + 15 ;
                            //averageCoordinates=[intersects[i].point.x, intersects[i].point.y, intersects[i].point.z];
                            addMarker(averageCoordinates, 0xff0000, "test");*/

                            return;
                        }
                    }
                }   
            }

            // color a mesh along its id and a chosen color and return its old color
            function colorAllObjectWithId(mesh, id, color){
		        var tmpColl = []
                for(let i=0; i< mesh.object.geometry.attributes.id.array.length; ++i){      
                    if (mesh.object.geometry.attributes.id.array[i] == id){
                        tmpColl.push(mesh.object.geometry.attributes.color.array[i*3])
                        tmpColl.push(mesh.object.geometry.attributes.color.array[i*3+1])
                        tmpColl.push(mesh.object.geometry.attributes.color.array[i*3+2])

                        mesh.object.geometry.attributes.color.array[i*3] = color[0];
                        mesh.object.geometry.attributes.color.array[i*3+1] = color[1];
                        mesh.object.geometry.attributes.color.array[i*3+2] = color[2];
                    }
                }
                mesh.object.geometry.attributes.color.needsUpdate = true; 
                globeView.notifyChange(true);
		        return tmpColl;
            }

            // Function that calculates the center coordinates of a mesh.
            function coordsAvgAllObjectWithId(mesh, id){
                var tmpCoord = [0, 0, 0];
                var maxZ = 0;
                var count = 0;
                for(let i=0; i< mesh.geometry.attributes.id.array.length; ++i){      
                    if (mesh.geometry.attributes.id.array[i] == id){
                        //console.log(mesh.pos[i]);
                        const coordinates = mesh.pos[i].as('EPSG:4326');  // Geographic system
                        tmpCoord[0] += coordinates.latitude();
                        tmpCoord[1] += coordinates.longitude();
                        tmpCoord[2] += coordinates.altitude();
                        count++;
                    }
                }
                tmpCoord[0] /=count;
                tmpCoord[1] /=count;
                tmpCoord[2] /=count;
		        return tmpCoord;
            }

            // Dumb function as an example to color buildings under water 
            // Should obviously be done in shaders but it shows how to access building meshes attribute
            function checkWaterHeightForBuildings(value) {
                console.log("e");
                // For all globe tile meshes we look for tile at level 14 on which building meshes are attached.
                for (let i = 0; i < globeView.wgs84TileLayer.level0Nodes.length; ++i) {
                    globeView.wgs84TileLayer.level0Nodes[i].traverse(function (element) {
                        //  console.log("ELEMENT: ", element);
                        if (element.level != undefined && element.level == 14 && element.visible) {
                            //console.log(element);
                            for (let c = 0; c < element.children.length; ++c) {

                                if (element.children[c].type == "Group") {
                                    var parent = element.children[c];
                                    var mesh = element.children[c].children[0];
                                    for (let j = 0; j < mesh.geometry.attributes.zmin.count; ++j) {
                                        let id = mesh.geometry.attributes.id.array[j];

                                        //important buidings
                                        if ( Object.keys(importantBuildings).includes(parent.features[id].properties.id) ){
                                            mesh.geometry.attributes.color.array[j * 3] = 255;
                                            mesh.geometry.attributes.color.array[j * 3 + 1] = 0;
                                            mesh.geometry.attributes.color.array[j * 3 + 2] = 0;
                                            mesh.geometry.attributes.color.needsUpdate = true;
                                        }
                                        // normal buildings
                                        else{
                                            var h = mesh.geometry.attributes.zmin.array[j]; 
                                            if (h > 0 && h < value) {
                                                mesh.geometry.attributes.color.array[j * 3] = 5 * (value - h);
                                                mesh.geometry.attributes.color.array[j * 3 + 1] = 0;
                                                mesh.geometry.attributes.color.array[j * 3 + 2] = 255;
                                                mesh.geometry.attributes.color.needsUpdate = true;
                                            }else{
                                                mesh.geometry.attributes.color.array[j * 3] = 255;
                                                mesh.geometry.attributes.color.array[j * 3 + 1] = 255;
                                                mesh.geometry.attributes.color.array[j * 3 + 2] = 255;
                                                mesh.geometry.attributes.color.needsUpdate = true;
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    })

                    globeView.notifyChange(true);
                }
            }

            function displayAllInteractionsForFloodedImportantBuildings(value) {
                console.log("i");
                // For all globe tile meshes we look for tile at level 14 on which building meshes are attached.
                for (let i = 0; i < globeView.wgs84TileLayer.level0Nodes.length; ++i) {
                    globeView.wgs84TileLayer.level0Nodes[i].traverse(function (element) {
                        //  console.log("ELEMENT: ", element);
                        if (element.level != undefined && element.level == 14 && element.visible) {
                            //console.log(element);
                            for (let c = 0; c < element.children.length; ++c) {

                                if (element.children[c].type == "Group") {
                                    var parent = element.children[c];
                                    var mesh = element.children[c].children[0];
                                    for (let j = 0; j < mesh.geometry.attributes.zmin.count; ++j) {
                                        let id = mesh.geometry.attributes.id.array[j];

                                        //important building
                                        if ( Object.keys(importantBuildings).includes(parent.features[id].properties.id) ){
                                            //red color of imortant buildings
                                            mesh.geometry.attributes.color.array[j * 3] = 255;
                                            mesh.geometry.attributes.color.array[j * 3 + 1] = 0;
                                            mesh.geometry.attributes.color.array[j * 3 + 2] = 0;
                                            mesh.geometry.attributes.color.needsUpdate = true;
                                            var h = mesh.geometry.attributes.zmin.array[j]; 

                                            //if the building is in contact with the water display a yellow sphere above it
                                            if (h > 0 && h < value) {
                                                var coord = coordsAvgAllObjectWithId(mesh, id);
                                                coord[2]*=parent.features[id].properties.hauteur+ parent.features[id].properties.z_max + 15 ;
                                                var a = globeView.scene.getObjectByName("test2" + parent.features[id].properties.id);
                                                if (!a) addMarker(coord, 0xffff00, "test2" + parent.features[id].properties.id);

                                                coordinatesImportantBuildings[parent.features[id].properties.id]=coord; //her I saved the marker position
                                            }
                                            // else remove the old marker
                                            else {
                                                var a = globeView.scene.getObjectByName("test2" + parent.features[id].properties.id);
                                                if (a) globeView.scene.remove(a);
                                            }
                                        } 

                                        //linked buildings
                                        
                                        else if (elementsLinked[parent.features[id].properties.id]){

                                            var importantBuildingsParents = elementsLinked[parent.features[id].properties.id];

                                            var listFloodedImportantBuildings = [];
                                            var b = false;

                                            for (var cp = 0; cp < importantBuildingsParents.length; cp++) {
                                                var tmpExistsObject = globeView.scene.getObjectByName("test2" + importantBuildingsParents[cp]);
                                                if (tmpExistsObject) {
                                                    listFloodedImportantBuildings.push(importantBuildingsParents[cp]);
                                                    b = true
                                                }
                                            }

                                            
                                            
                                            //at least one important linked building is flooded
                                            if (b) {

                                                //here trace the interactions
                                                var coord = coordsAvgAllObjectWithId(mesh, id);
                                                coord[2]*=parent.features[id].properties.hauteur+ parent.features[id].properties.z_max + 15 ;

                                                listFloodedImportantBuildings.forEach(el => {
                                                    importantCoord = coordinatesImportantBuildings[el]
                                                    traceLine(coord,importantCoord);
                                                    console.log("pas_coll");
                                                });

                                                mesh.geometry.attributes.color.array[j * 3] = 255;
                                                mesh.geometry.attributes.color.array[j * 3 + 1] = 255;
                                                mesh.geometry.attributes.color.array[j * 3 + 2] = 0;
                                                mesh.geometry.attributes.color.needsUpdate = true;
                                            }
                                            //normal case
                                            else{
                                                var h = mesh.geometry.attributes.zmin.array[j]; 
                                                if (h > 0 && h < value) {
                                                    mesh.geometry.attributes.color.array[j * 3] = 5 * (value - h);
                                                    mesh.geometry.attributes.color.array[j * 3 + 1] = 0;
                                                    mesh.geometry.attributes.color.array[j * 3 + 2] = 255;
                                                    mesh.geometry.attributes.color.needsUpdate = true;
                                                }else{
                                                    mesh.geometry.attributes.color.array[j * 3] = 255;
                                                    mesh.geometry.attributes.color.array[j * 3 + 1] = 255;
                                                    mesh.geometry.attributes.color.array[j * 3 + 2] = 255;
                                                    mesh.geometry.attributes.color.needsUpdate = true;
                                                }
                                            }
                                        }

                                        //normal buildings
                                        else{
                                            var h = mesh.geometry.attributes.zmin.array[j]; 
                                            if (h > 0 && h < value) {
                                                mesh.geometry.attributes.color.array[j * 3] = 5 * (value - h);
                                                mesh.geometry.attributes.color.array[j * 3 + 1] = 0;
                                                mesh.geometry.attributes.color.array[j * 3 + 2] = 255;
                                                mesh.geometry.attributes.color.needsUpdate = true;
                                            }else{
                                                mesh.geometry.attributes.color.array[j * 3] = 255;
                                                mesh.geometry.attributes.color.array[j * 3 + 1] = 255;
                                                mesh.geometry.attributes.color.array[j * 3 + 2] = 255;
                                                mesh.geometry.attributes.color.needsUpdate = true;
                                            }
                                        }
                                        
                                    }
                                }
                            }

                        }

                    })

                    globeView.notifyChange(true);
                }
            }

            // add  marker at the position describe by coords
            function addMarker(coords, color, name) {
                // creation of the new mesh (a cylinder)
                //console.log("e");
                var THREE = itowns.THREE;
                var geometry = new THREE.SphereGeometry( 12, 32, 32 ); //a sphere is visible from all the directions under the same angle
                var material = new THREE.MeshBasicMaterial({ color: color });
                var mesh = new THREE.Mesh(geometry, material);

                // get the position on the globe, from the camera
                
                // position of the mesh
                //var meshCoord = new THREE.Vector3(coords[0], coords[1], coords[2]);
                var meshCoord = new itowns.Coordinates('EPSG:4326', coords[1], coords[0], coords[2]);
                //console.log(meshCoord.as(globeView.referenceCrs));
                // position and orientation of the mesh
                mesh.name=name;
                mesh.position.copy(meshCoord.as(globeView.referenceCrs).xyz());
                mesh.lookAt(new THREE.Vector3(0, 0, 0));
                //mesh.rotateX(Math.PI / 2);

                // update coordinate of the mesh
                mesh.updateMatrixWorld();
                //console.log(mesh);
                // add the mesh to the scene
                globeView.scene.add(mesh);
            }

            // return true if the key is linked to the value
            function isLinked(key, value){
                for (let t = 0; t<elementsLinked[key].length; t++){
                    if(elementsLinked[key][t]==value){
                        return true;
                    }
                }
                return false;
            }

            function createLine(parent){
                if(!coordsElementsLinked){
                    var coordsElementsLinked = extract_coords();//id_BDTopo élément, coordonnées : [long, lat, alti]
                }
                for (let i =0; i<linkedElements[parent].length; i++){
                    coords1=coordsElementsLinked[parent];
                    coords2=coordsElementsLinked[linkedElements[parent][i]];
                    var material = new THREE.LineBasicMaterial({
                        color: 0x0000ff
                    });
                    var meshcoord1 = new itowns.Coordinates('EPSG:4326', coords1[1], coords1[0], coords1[2]).as(globeView.referenceCrs);
                    var meshCoord2 = new itowns.Coordinates('EPSG:4326', coords2[1], coords2[0], coords2[2]).as(globeView.referenceCrs);
                    var geometry = new THREE.Geometry();
                    geometry.vertices.push(
                        new THREE.Vector3( meshcoord1.x(), meshcoord1.y(), meshcoord1.z()),
                        new THREE.Vector3( meshCoord2.x(), meshCoord2.y(), meshCoord2.z())
                    );

                    var line = new THREE.Line( geometry, material );
                    globeView.scene.add( line );
                }                
            }

            function traceLine(coords1,coords2) {
                var THREE = itowns.THREE;
                var material = new THREE.LineBasicMaterial({
                        color: 0x0000ff
                    });
                    var meshcoord1 = new itowns.Coordinates('EPSG:4326', coords1[1], coords1[0], coords1[2]).as(globeView.referenceCrs);
                    var meshCoord2 = new itowns.Coordinates('EPSG:4326', coords2[1], coords2[0], coords2[2]).as(globeView.referenceCrs);
                    var geometry = new THREE.Geometry();
                    geometry.vertices.push(
                        new THREE.Vector3( meshcoord1.x(), meshcoord1.y(), meshcoord1.z()),
                        new THREE.Vector3( meshCoord2.x(), meshCoord2.y(), meshCoord2.z())
                    );

                    var line = new THREE.Line( geometry, material );
                    line.name = 'interaction';
                    globeView.scene.add( line );
            }

            function removeOldInteractions(argument) {
                var a = globeView.scene.getObjectByName("interaction");
                let i=0;
                while(a){
                    console.log(a);
                    globeView.scene.remove(a);
                    a = globeView.scene.getObjectByName("interaction");
                }                
            }

            function reverseJson(json){
                var result ={};
                Object.keys(json).map(function(objectKey) {
                    var value = json[objectKey];
                    value.forEach(el => ( (! result[el]) ? result[el]=[objectKey] : result[el].push(objectKey)) );
                });
                return result;
            }

        </script>
    </body>
</html>
